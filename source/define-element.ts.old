// import createNoop from './helpers/noop.js'
// import kebabToPascal from './helpers/kebab-to-pascal.js'
// import { TemplateResult } from '../node_modules/lit-html/lit-html.js'
// import generateId from './helpers/generate-id.js'
import { html, render, TemplateResult, Template } from '../node_modules/lit-html/lit-html.js'
import camelToKebab from './helpers/camel-to-kebab.js'
import css from './helpers/parse-css.js'
import CustomElement, { LifeCycleEvents, LifeCycleHandler } from './create-element/custom-element-base.js'

// Reexport for developer convenience.
export { css }
export { html }
export type ParseHTML = typeof html
export type ParseCSS = typeof css

/**
 * Configures the attribute's expected type and value.
 */
export type AttributeDefinition = {
  /**
   * A JSON friendly constructor function.
   */
  type: (...args: any[]) => any
  defaultValue?: string | number | boolean | null | (() => any)
}

export type AttributeDefinitions = {
  [attr: string]: AttributeDefinition
}

export type WithAttributes<AD extends AttributeDefinitions> = { [P in keyof AD]: ReturnType<AD[P]['type']> }

const attrs = {
  foo: {
    type: Number,
    defaultValue: 5
  },
  bar: {
    type: String,
    defaultValue: '3454'
  },
  qux: {
    type: String,
    defaultValue: 123
  }
}

const sample = {} as WithAttributes<typeof attrs>

console.log(sample.foo, sample.qux)

type CustomElementEventDetail<E, C> = keyof E extends Function ? Record<keyof E, (this: C) => void> : Record<keyof E, E>

export interface CustomElementEventDefintions<E, C> {
  [eventName: string]: CustomEventInit<CustomElementEventDetail<E, C>>
  // [eventName: string]: CustomEventInit<Record<keyof E, (this: Element) => void>>
}

export type BoundMethods<AD extends AttributeDefinitions, M, E> = Record<
  keyof M,
  (this: CustomElement<WithAttributes<AD>> & BoundMethods<AD, M, E>, ...args: any) => any
>

// export type BoundMethods<AD extends AttributeDefinitions, M, E> = (...args: any[]) => any

export interface DefineElementOptions<AD extends AttributeDefinitions, M, E> {
  // styles?: CustomElementBase<AD>['styles']
  // template: any
  template: (this: any, html: ParseHTML) => TemplateResult
  // template: (this: BoundMethods<AD, M, E>, html: ParseHTML) => TemplateResult
  lifecycle?: Partial<{ [key in LifeCycleEvents]: LifeCycleHandler<AD> }>
  shadowRoot?: ShadowRootInit
  attributes: AD
  methods?: BoundMethods<AD, M, E>
  events?: E
}

export abstract class CustomElement<AD extends AttributeDefinitions, M, E> extends CustomElement<WithAttributes<AD>> {}
// implements BoundMethods<AD, M, E>

// = new (...args: any) => CustomElementBase<
//   WithAttributes<AD>
// > &
//   BoundMethods<AD, M, E>

/**
 *
 * @param tagName A unique name with dashes-between-words, or camelCased.
 * @param options Options describing your element's behavior.
 */
function defineElement<
  AD extends AttributeDefinitions,
  M extends object,
  E extends CustomElementEventDefintions<E, CustomElement<WithAttributes<AD>>>
>(tagName: string, options: DefineElementOptions<AD, M, E>): CustomElement<WithAttributes<AD>, M, E> {
  tagName = camelToKebab(tagName)

  const prexistingElement: Element | undefined = window.customElements.get(tagName)

  if (prexistingElement) {
    console.error(`${tagName}: An element with the same name was already defined.`, prexistingElement)
  }

  if (tagName.indexOf('-') === -1) {
    throw new Error(
      `${tagName}: Custom elements must have a dash (-) in their tag name to avoid overlap with pre-existing elements.`
    )
  }

  const methods = options.methods || ({} as BoundMethods<AD, M, E>)
  const extendedPrototype = { ...methods, template: options.template }

  type CustomElementEvents = Record<keyof E, () => void>
  // CustomEventInit<Record<keyof E, E extends Function ? (this: )>>

  class CustomElementDefined extends CustomElement<AD> {
    // static get tagName() {
    //   return tagName
    // }

    events: CustomElementEvents

    constructor() {
      super()

      const eventDefinitions = options.events || ({} as E)
      this.events = {} as CustomElementEvents

      for (const [eventName, eventInit] of Object.entries(eventDefinitions)) {
        this.events[eventName] = () => {
          this.triggerEvent(eventName, eventInit)
        }
      }

      this.triggerEvent(LifeCycleEvents.afterInsert, {
        cancelable: false
      })
    }
  }

  Object.assign(CustomElementDefined.prototype, extendedPrototype)

  // return (CustomElementDefined as unknown) as CustomElement<WithAttributes<AD>, M, E>
  return CustomElementDefined
}

const Foo = defineElement('foo-bar', {
  attributes: {
    // foo: String,
    bar: {
      type: Number,
      defaultValue: 5
    },
    baz: {
      type: String
    }
  },
  events: {
    itemsFetched: {
      bubbles: true,
      cancelable: true,
      detail: {
        foo() {
          // this.handleClick()
          // return (this as typeof Foo).handleClick()
        }
        // bar() {
        //   console.log(this.attributes.bar, this.attributes.baz)
        //   return this.children
        // }
      }
    }
  },
  //
  lifecycle: {
    // beforeInsert() {
    //   console.log(this.attributes.foo)
    // }
  },
  methods: {
    handleClick(event: MouseEvent) {
      // console.log(event, this.attributes.foo)
      this.tagName
      this.attributes.bar
      this.zazz()
      return event.defaultPrevented
    },
    zazz: () => 123,
    foo() {
      return (this as any).attributes
    }
  },
  template(html) {
    this.attributes.bar
    const foo = this.zazz()
    return html`
      <div>Hello</div>
    `
  }
})

const instance = new Foo()
instance.tagName
// instance.template()
instance.onbeforeinsert = function(event: Event) {
  console.log('before insert!', event)
}

instance.handleClick(new MouseEvent('click'))
// instance.zag()
// instance.events.itemsFetched()

instance.attributes.bar
instance.attributes.getNamedItem

export default defineElement
